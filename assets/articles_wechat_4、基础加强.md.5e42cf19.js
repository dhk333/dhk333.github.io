import{_ as a,c as e,o as i,a as p}from"./app.2614b7c5.js";const u=JSON.parse('{"title":"自定义组件","description":"","frontmatter":{},"headers":[{"level":2,"title":"组件的创建与引用","slug":"组件的创建与引用","link":"#组件的创建与引用","children":[{"level":3,"title":"创建组件","slug":"创建组件","link":"#创建组件","children":[]},{"level":3,"title":"引用组件","slug":"引用组件","link":"#引用组件","children":[]}]},{"level":2,"title":"组件和页面的区别","slug":"组件和页面的区别","link":"#组件和页面的区别","children":[]},{"level":2,"title":"样式","slug":"样式","link":"#样式","children":[{"level":3,"title":"组件样式隔离","slug":"组件样式隔离","link":"#组件样式隔离","children":[]},{"level":3,"title":"组件样式隔离的注意点","slug":"组件样式隔离的注意点","link":"#组件样式隔离的注意点","children":[]},{"level":3,"title":"修改组件的样式隔离选项","slug":"修改组件的样式隔离选项","link":"#修改组件的样式隔离选项","children":[]}]},{"level":2,"title":"数据、方法和属性","slug":"数据、方法和属性","link":"#数据、方法和属性","children":[{"level":3,"title":"data 数据","slug":"data-数据","link":"#data-数据","children":[]},{"level":3,"title":"methods 方法","slug":"methods-方法","link":"#methods-方法","children":[]},{"level":3,"title":"properties 属性","slug":"properties-属性","link":"#properties-属性","children":[]},{"level":3,"title":"data 和 properties 的区别","slug":"data-和-properties-的区别","link":"#data-和-properties-的区别","children":[]},{"level":3,"title":"使用 setData 修改 properties 的值","slug":"使用-setdata-修改-properties-的值","link":"#使用-setdata-修改-properties-的值","children":[]}]},{"level":2,"title":"数据监听器","slug":"数据监听器","link":"#数据监听器","children":[{"level":3,"title":"什么是数据监听器","slug":"什么是数据监听器","link":"#什么是数据监听器","children":[]},{"level":3,"title":"数据监听器的基本用法","slug":"数据监听器的基本用法","link":"#数据监听器的基本用法","children":[]},{"level":3,"title":"监听对象属性的变化","slug":"监听对象属性的变化","link":"#监听对象属性的变化","children":[]}]},{"level":2,"title":"纯数据字段","slug":"纯数据字段","link":"#纯数据字段","children":[{"level":3,"title":"什么是纯数据字段","slug":"什么是纯数据字段","link":"#什么是纯数据字段","children":[]},{"level":3,"title":"使用规则","slug":"使用规则","link":"#使用规则","children":[]},{"level":3,"title":"使用纯数据字段改造数据监听器案例","slug":"使用纯数据字段改造数据监听器案例","link":"#使用纯数据字段改造数据监听器案例","children":[]}]},{"level":2,"title":"组件的生命周期","slug":"组件的生命周期","link":"#组件的生命周期","children":[{"level":3,"title":"组件全部的生命周期函数","slug":"组件全部的生命周期函数","link":"#组件全部的生命周期函数","children":[]},{"level":3,"title":"组件主要的生命周期函数","slug":"组件主要的生命周期函数","link":"#组件主要的生命周期函数","children":[]},{"level":3,"title":"lifetimes 节点","slug":"lifetimes-节点","link":"#lifetimes-节点","children":[]}]},{"level":2,"title":"组件所在页面的生命周期","slug":"组件所在页面的生命周期","link":"#组件所在页面的生命周期","children":[{"level":3,"title":"什么是组件所在页面的生命周期","slug":"什么是组件所在页面的生命周期","link":"#什么是组件所在页面的生命周期","children":[]},{"level":3,"title":"pageLifetimes 节点","slug":"pagelifetimes-节点","link":"#pagelifetimes-节点","children":[]},{"level":3,"title":"生成随机的 RGB 颜色值","slug":"生成随机的-rgb-颜色值","link":"#生成随机的-rgb-颜色值","children":[]}]},{"level":2,"title":"插槽","slug":"插槽","link":"#插槽","children":[{"level":3,"title":"什么是插槽","slug":"什么是插槽","link":"#什么是插槽","children":[]},{"level":3,"title":"单个插槽","slug":"单个插槽","link":"#单个插槽","children":[]},{"level":3,"title":"启用多个插槽","slug":"启用多个插槽","link":"#启用多个插槽","children":[]},{"level":3,"title":"定义多个插槽","slug":"定义多个插槽","link":"#定义多个插槽","children":[]},{"level":3,"title":"使用多个插槽","slug":"使用多个插槽","link":"#使用多个插槽","children":[]}]},{"level":2,"title":"父子组件之间的通信","slug":"父子组件之间的通信","link":"#父子组件之间的通信","children":[{"level":3,"title":"父子组件之间通信的 3 种方式","slug":"父子组件之间通信的-3-种方式","link":"#父子组件之间通信的-3-种方式","children":[]},{"level":3,"title":"属性绑定","slug":"属性绑定","link":"#属性绑定","children":[]},{"level":3,"title":"事件绑定","slug":"事件绑定","link":"#事件绑定","children":[]},{"level":3,"title":"获取组件实例","slug":"获取组件实例","link":"#获取组件实例","children":[]}]},{"level":2,"title":"behaviors","slug":"behaviors","link":"#behaviors","children":[{"level":3,"title":"什么是 behaviors","slug":"什么是-behaviors","link":"#什么是-behaviors","children":[]},{"level":3,"title":"behaviors 的工作方式","slug":"behaviors-的工作方式","link":"#behaviors-的工作方式","children":[]},{"level":3,"title":"创建 behavior","slug":"创建-behavior","link":"#创建-behavior","children":[]},{"level":3,"title":"导入并使用 behavior","slug":"导入并使用-behavior","link":"#导入并使用-behavior","children":[]},{"level":3,"title":"behavior 中所有可用的节点","slug":"behavior-中所有可用的节点","link":"#behavior-中所有可用的节点","children":[]},{"level":3,"title":"同名字段的覆盖和组合规则*","slug":"同名字段的覆盖和组合规则","link":"#同名字段的覆盖和组合规则","children":[]}]},{"level":2,"title":"小程序对 npm 的支持与限制","slug":"小程序对-npm-的支持与限制","link":"#小程序对-npm-的支持与限制","children":[]},{"level":2,"title":"Vant Weapp","slug":"vant-weapp","link":"#vant-weapp","children":[{"level":3,"title":"什么是 Vant Weapp","slug":"什么是-vant-weapp","link":"#什么是-vant-weapp","children":[]},{"level":3,"title":"安装 Vant 组件库","slug":"安装-vant-组件库","link":"#安装-vant-组件库","children":[]},{"level":3,"title":"使用 Vant 组件","slug":"使用-vant-组件","link":"#使用-vant-组件","children":[]},{"level":3,"title":"定制全局主题样式","slug":"定制全局主题样式","link":"#定制全局主题样式","children":[]}]},{"level":2,"title":"API Promise化","slug":"api-promise化","link":"#api-promise化","children":[{"level":3,"title":"基于回调函数的异步 API 的缺点","slug":"基于回调函数的异步-api-的缺点","link":"#基于回调函数的异步-api-的缺点","children":[]},{"level":3,"title":"什么是 API Promise 化","slug":"什么是-api-promise-化","link":"#什么是-api-promise-化","children":[]},{"level":3,"title":"实现 API Promise 化","slug":"实现-api-promise-化","link":"#实现-api-promise-化","children":[]},{"level":3,"title":"调用 Promise 化之后的异步 API","slug":"调用-promise-化之后的异步-api","link":"#调用-promise-化之后的异步-api","children":[]}]},{"level":2,"title":"什么是全局数据共享","slug":"什么是全局数据共享","link":"#什么是全局数据共享","children":[]},{"level":2,"title":"小程序中的全局数据共享方案","slug":"小程序中的全局数据共享方案","link":"#小程序中的全局数据共享方案","children":[{"level":3,"title":"MobX","slug":"mobx","link":"#mobx","children":[]}]},{"level":2,"title":"什么是分包","slug":"什么是分包","link":"#什么是分包","children":[]},{"level":2,"title":"分包的好处","slug":"分包的好处","link":"#分包的好处","children":[]},{"level":2,"title":"分包前项目的构成","slug":"分包前项目的构成","link":"#分包前项目的构成","children":[]},{"level":2,"title":"分包后项目的构成","slug":"分包后项目的构成","link":"#分包后项目的构成","children":[]},{"level":2,"title":"分包的加载规则","slug":"分包的加载规则","link":"#分包的加载规则","children":[]},{"level":2,"title":"分包的体积限制","slug":"分包的体积限制","link":"#分包的体积限制","children":[]},{"level":2,"title":"使用分包","slug":"使用分包","link":"#使用分包","children":[{"level":3,"title":"配置方法","slug":"配置方法","link":"#配置方法","children":[]},{"level":3,"title":"打包原则","slug":"打包原则","link":"#打包原则","children":[]},{"level":3,"title":"引用原则","slug":"引用原则","link":"#引用原则","children":[]}]},{"level":2,"title":"独立分包","slug":"独立分包","link":"#独立分包","children":[{"level":3,"title":"什么是独立分包","slug":"什么是独立分包","link":"#什么是独立分包","children":[]},{"level":3,"title":"独立分包和普通分包的区别","slug":"独立分包和普通分包的区别","link":"#独立分包和普通分包的区别","children":[]},{"level":3,"title":"独立分包的应用场景","slug":"独立分包的应用场景","link":"#独立分包的应用场景","children":[]},{"level":3,"title":"独立分包的配置方法","slug":"独立分包的配置方法","link":"#独立分包的配置方法","children":[]},{"level":3,"title":"引用原则","slug":"引用原则-1","link":"#引用原则-1","children":[]}]},{"level":2,"title":"分包预下载","slug":"分包预下载","link":"#分包预下载","children":[{"level":3,"title":"什么是分包预下载","slug":"什么是分包预下载","link":"#什么是分包预下载","children":[]},{"level":3,"title":"配置分包的预下载","slug":"配置分包的预下载","link":"#配置分包的预下载","children":[]},{"level":3,"title":"分包预下载的限制","slug":"分包预下载的限制","link":"#分包预下载的限制","children":[]}]},{"level":2,"title":"案例效果","slug":"案例效果","link":"#案例效果","children":[]},{"level":2,"title":"实现步骤","slug":"实现步骤","link":"#实现步骤","children":[]}],"relativePath":"articles/wechat/4、基础加强.md","lastUpdated":1678786121000}'),t={name:"articles/wechat/4、基础加强.md"},d=p('<h1 id="自定义组件" tabindex="-1">自定义组件 <a class="header-anchor" href="#自定义组件" aria-hidden="true">#</a></h1><h2 id="组件的创建与引用" tabindex="-1">组件的创建与引用 <a class="header-anchor" href="#组件的创建与引用" aria-hidden="true">#</a></h2><h3 id="创建组件" tabindex="-1">创建组件 <a class="header-anchor" href="#创建组件" aria-hidden="true">#</a></h3><ol><li>在项目的根目录中，鼠标右键，创建 <code>components</code> -&gt; <code>test</code> 文件夹</li><li>在新建的 <code>components</code> -&gt; <code>test</code> 文件夹上，鼠标右键，点击“新建 <code>Component</code>”</li><li>键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 <code>.js</code>，<code>.json</code>，<code> .wxml</code> 和 <code>.wxss </code></li></ol><p>注意：为了保证目录结构的清晰，建议把不同的组件，存放到单独目录中，例如： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678707800004-4d1d4487-dbdb-40c2-b2b0-8851831ffc01.png#averageHue=%23fbfaf8&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=306&amp;id=u9c29a456&amp;name=image.png&amp;originHeight=398&amp;originWidth=273&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=13999&amp;status=done&amp;style=none&amp;taskId=u7406e781-82d7-4e35-9425-69b197404dc&amp;title=&amp;width=209.6639936015627" alt="image.png"></p><h3 id="引用组件" tabindex="-1">引用组件 <a class="header-anchor" href="#引用组件" aria-hidden="true">#</a></h3><p>组件的引用方式分为“局部引用”和“全局引用”，顾名思义：</p><ol><li>局部引用：组件只能在当前被引用的页面内使用</li><li>全局引用：组件可以在每个小程序页面中使用</li></ol><h4 id="局部引用组件" tabindex="-1">局部引用组件 <a class="header-anchor" href="#局部引用组件" aria-hidden="true">#</a></h4><p>在页面的 <code>.json</code> 配置文件中引用组件的方式，叫做“局部引用”。示例代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708052301-efe82b24-01f3-4cc4-8188-555475cd3881.png#averageHue=%23fbfbfb&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=237&amp;id=u0a38d293&amp;name=image.png&amp;originHeight=308&amp;originWidth=962&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=27422&amp;status=done&amp;style=none&amp;taskId=u65cefcc1-2613-4d2a-85cc-fc30a815301&amp;title=&amp;width=738.8159774531257" alt="image.png"></p><h4 id="全局引用组件" tabindex="-1">全局引用组件 <a class="header-anchor" href="#全局引用组件" aria-hidden="true">#</a></h4><p>在 <code>app.json</code> 全局配置文件中引用组件的方式，叫做“全局引用”。示例代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708203260-2cf53934-df7d-42c7-a3bd-47e1c94c931d.png#averageHue=%23fcfcfb&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=378&amp;id=u4021b7bd&amp;name=image.png&amp;originHeight=492&amp;originWidth=963&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=52458&amp;status=done&amp;style=none&amp;taskId=u2283c8c6-c75c-4d2b-9d7c-e679516b7c6&amp;title=&amp;width=739.5839774296882" alt="image.png"></p><h4 id="全局引用-vs-局部引用" tabindex="-1">全局引用 VS 局部引用 <a class="header-anchor" href="#全局引用-vs-局部引用" aria-hidden="true">#</a></h4><p>根据组件的使用频率和范围，来选择合适的引用方式：</p><ol><li>如果某组件在多个页面中经常被用到，建议进行“全局引用”</li><li>如果某组件只在特定的页面中被用到，建议进行“局部引用”</li></ol><h2 id="组件和页面的区别" tabindex="-1">组件和页面的区别 <a class="header-anchor" href="#组件和页面的区别" aria-hidden="true">#</a></h2><p>从表面来看，组件和页面都是由 <code>.js</code>、<code>.json</code>、<code>.wxml</code> 和 <code>.wxss</code> 这四个文件组成的。但是，组件和页面的 .js 与 <code>.json</code> 文件有明显的不同： ⚫ 组件的 <code>.json</code> 文件中需要声明 <code>&quot;component&quot;: true</code> 属性 ⚫ 组件的 <code>.js</code> 文件中调用的是 <code>Component() </code>函数 ⚫ 组件的事件处理函数需要定义到 <code>methods</code> 节点中</p><h2 id="样式" tabindex="-1">样式 <a class="header-anchor" href="#样式" aria-hidden="true">#</a></h2><h3 id="组件样式隔离" tabindex="-1">组件样式隔离 <a class="header-anchor" href="#组件样式隔离" aria-hidden="true">#</a></h3><p>默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的 UI 结构，如图所示： ⚫ 组件 A 的样式不会影响组件 C 的样式 ⚫ 组件 A 的样式不会影响小程序页面的样式 ⚫ 小程序页面的样式不会影响组件 A 和 C 的样式 好处： ① 防止外界的样式影响组件内部的样式 ② 防止组件的样式破坏外界的样式 <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708302709-794f077d-7e65-4de8-b762-2f1b5a3c5562.png#averageHue=%23c3ddfd&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=374&amp;id=ud10a357b&amp;name=image.png&amp;originHeight=487&amp;originWidth=301&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=12955&amp;status=done&amp;style=none&amp;taskId=ub4500145-5c2e-4a23-968b-bc23e327b81&amp;title=&amp;width=231.1679929453127" alt="image.png"></p><h3 id="组件样式隔离的注意点" tabindex="-1">组件样式隔离的注意点 <a class="header-anchor" href="#组件样式隔离的注意点" aria-hidden="true">#</a></h3><p><code>app.wxss</code> 中的全局样式对组件无效 只有 <code>class</code> 选择器会有样式隔离效果，<code>id</code> 选择器、属性选择器、标签选择器不受样式隔离的影响 建议：在组件和引用组件的页面中建议使用 <code>class</code> 选择器，不要使用 <code>id</code>、属性、标签选择器！</p><h3 id="修改组件的样式隔离选项" tabindex="-1">修改组件的样式隔离选项 <a class="header-anchor" href="#修改组件的样式隔离选项" aria-hidden="true">#</a></h3><p>默认情况下，自定义组件的样式隔离特性能够防止组件内外样式互相干扰的问题。但有时，我们希望在外界能 够控制组件内部的样式，此时，可以通过 <code>styleIsolation</code> 修改组件的样式隔离选项，用法如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708411476-08296ee8-6ec4-484f-9636-0cf0dcfb2929.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=335&amp;id=u50732bd0&amp;name=image.png&amp;originHeight=436&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=61557&amp;status=done&amp;style=none&amp;taskId=u57286a08-92a0-419a-a554-1586332d139&amp;title=&amp;width=575.9999824218755" alt="image.png"></p><h4 id="styleisolation-的可选值" tabindex="-1">styleIsolation 的可选值 <a class="header-anchor" href="#styleisolation-的可选值" aria-hidden="true">#</a></h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708424942-a38ad4ae-1f82-428c-b74f-821f9d71077c.png#averageHue=%235d89bc&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=230&amp;id=u320812e4&amp;name=image.png&amp;originHeight=300&amp;originWidth=1178&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=120990&amp;status=done&amp;style=none&amp;taskId=u0b6df9fc-c3cb-4a13-a161-060b48d5b3d&amp;title=&amp;width=904.7039723906258" alt="image.png"></p><h2 id="数据、方法和属性" tabindex="-1">数据、方法和属性 <a class="header-anchor" href="#数据、方法和属性" aria-hidden="true">#</a></h2><h3 id="data-数据" tabindex="-1">data 数据 <a class="header-anchor" href="#data-数据" aria-hidden="true">#</a></h3><p>在小程序组件中，用于组件模板渲染的私有数据，需要定义到 <code>data</code> 节点中，示例如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708457492-5ca59c06-42f4-487b-bd41-ba5142d858c0.png#averageHue=%230c1121&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=297&amp;id=uc01f75d0&amp;name=image.png&amp;originHeight=387&amp;originWidth=832&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=50627&amp;status=done&amp;style=none&amp;taskId=ub791afa3-4504-406a-a1c2-1b3bdf436f6&amp;title=&amp;width=638.9759805000006" alt="image.png"></p><h3 id="methods-方法" tabindex="-1">methods 方法 <a class="header-anchor" href="#methods-方法" aria-hidden="true">#</a></h3><p>在小程序组件中，事件处理函数和 自定义方法需要定义到 <code>methods</code> 节点中，示例代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708486575-3785d4ad-464d-49a0-9efa-6c14a328f711.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=374&amp;id=uab0cb018&amp;name=image.png&amp;originHeight=487&amp;originWidth=745&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=91599&amp;status=done&amp;style=none&amp;taskId=u8a8ab65f-45af-4e8b-8118-914843711ff&amp;title=&amp;width=572.159982539063" alt="image.png"></p><h3 id="properties-属性" tabindex="-1">properties 属性 <a class="header-anchor" href="#properties-属性" aria-hidden="true">#</a></h3><p>在小程序组件中，<code>properties</code> 是组件的对外属性，用来接收外界传递到组件中的数据，示例代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708518157-6e592548-10e5-46a0-afc3-703f0c00887a.png#averageHue=%230d1223&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=339&amp;id=u2e6c4f4d&amp;name=image.png&amp;originHeight=442&amp;originWidth=808&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=97851&amp;status=done&amp;style=none&amp;taskId=u9113a823-1f8b-40ef-9ec4-23558efa8e8&amp;title=&amp;width=620.5439810625006" alt="image.png"></p><h3 id="data-和-properties-的区别" tabindex="-1">data 和 properties 的区别 <a class="header-anchor" href="#data-和-properties-的区别" aria-hidden="true">#</a></h3><p>在小程序的组件中，<code>properties</code> 属性和 <code>data</code> 数据的用法相同，它们都是可读可写的，只不过：</p><ol><li><code>data</code> 更倾向于存储组件的私有数据</li><li><code>properties</code> 更倾向于存储外界传递到组件中的数据</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708544336-52e83b92-db12-4d4f-ad80-e5bf16b4e87b.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=292&amp;id=u2f68fdd4&amp;name=image.png&amp;originHeight=380&amp;originWidth=820&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=78894&amp;status=done&amp;style=none&amp;taskId=udd335d82-7a98-4718-9368-2c1834604b4&amp;title=&amp;width=629.7599807812505" alt="image.png"></p><h3 id="使用-setdata-修改-properties-的值" tabindex="-1">使用 setData 修改 properties 的值 <a class="header-anchor" href="#使用-setdata-修改-properties-的值" aria-hidden="true">#</a></h3><p>由于<code>data</code> 数据和 <code>properties</code> 属性在本质上没有任何区别，因此 <code>properties</code> 属性的值也可以用于页面渲染， 或使用 <code>setData</code> 为 <code>properties</code> 中的属性重新赋值，示例代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708575773-da7a6c57-891b-4f3c-b06c-cf194cf5e4fd.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=325&amp;id=u876f8c3a&amp;name=image.png&amp;originHeight=423&amp;originWidth=844&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=79487&amp;status=done&amp;style=none&amp;taskId=u4eb4b605-4ee6-4d6a-a535-07be746c1b3&amp;title=&amp;width=648.1919802187506" alt="image.png"></p><h2 id="数据监听器" tabindex="-1">数据监听器 <a class="header-anchor" href="#数据监听器" aria-hidden="true">#</a></h2><h3 id="什么是数据监听器" tabindex="-1">什么是数据监听器 <a class="header-anchor" href="#什么是数据监听器" aria-hidden="true">#</a></h3><p>数据监听器用于监听和响应任何属性和数据字段的变化，从而执行特定的操作。它的作用类似于 <code>vue</code> 中的 <code>watch</code> 侦听器。在小程序组件中，数据监听器的基本语法格式如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708596671-b9d4707d-320a-4044-b424-f4f25ea89746.png#averageHue=%230d1121&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=223&amp;id=u26fe7b45&amp;name=image.png&amp;originHeight=291&amp;originWidth=824&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=48826&amp;status=done&amp;style=none&amp;taskId=ub50a4dbd-8396-40aa-b926-2c56db192c2&amp;title=&amp;width=632.8319806875006" alt="image.png"></p><h3 id="数据监听器的基本用法" tabindex="-1">数据监听器的基本用法 <a class="header-anchor" href="#数据监听器的基本用法" aria-hidden="true">#</a></h3><p>组件的 UI 结构如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708616907-ea17ed10-f90f-467c-8202-c48a762bf804.png#averageHue=%230d1222&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=157&amp;id=u32037b05&amp;name=image.png&amp;originHeight=204&amp;originWidth=838&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=59680&amp;status=done&amp;style=none&amp;taskId=uc51b8645-953c-4e1b-a3f9-18429ea4f1e&amp;title=&amp;width=643.5839803593756" alt="image.png"> 组件的<code>.js </code>文件代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708628201-601379d9-818a-4f35-8a3a-dd2fd7947b88.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=356&amp;id=u70b2885b&amp;name=image.png&amp;originHeight=463&amp;originWidth=834&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=99112&amp;status=done&amp;style=none&amp;taskId=u861cab5f-0c95-4396-832a-b636e215b3d&amp;title=&amp;width=640.5119804531256" alt="image.png"></p><h3 id="监听对象属性的变化" tabindex="-1">监听对象属性的变化 <a class="header-anchor" href="#监听对象属性的变化" aria-hidden="true">#</a></h3><p>数据监听器支持监听对象中单个或多个属性的变化，示例语法如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708649883-772acd9d-c4d8-4629-95c1-fe01b2698f92.png#averageHue=%230e1223&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=326&amp;id=u15ec37a6&amp;name=image.png&amp;originHeight=424&amp;originWidth=859&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=102577&amp;status=done&amp;style=none&amp;taskId=u4020fb50-da2e-45a9-b0de-ff1ef2dfaf9&amp;title=&amp;width=659.7119798671881" alt="image.png"></p><h4 id="监听对象中所有属性的变化" tabindex="-1">监听对象中所有属性的变化 <a class="header-anchor" href="#监听对象中所有属性的变化" aria-hidden="true">#</a></h4><p>如果某个对象中需要被监听的属性太多，为了方便，可以使用通配符<code>**</code>来监听对象中所有属性的变化，示例 代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708681221-9e9cce2b-df2e-4719-a42f-0f918c8ca7a3.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=260&amp;id=u6dec30a5&amp;name=image.png&amp;originHeight=339&amp;originWidth=822&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=57943&amp;status=done&amp;style=none&amp;taskId=u85e50f85-0fb4-4b08-b832-480bac0f15f&amp;title=&amp;width=631.2959807343756" alt="image.png"></p><h2 id="纯数据字段" tabindex="-1">纯数据字段 <a class="header-anchor" href="#纯数据字段" aria-hidden="true">#</a></h2><h3 id="什么是纯数据字段" tabindex="-1">什么是纯数据字段 <a class="header-anchor" href="#什么是纯数据字段" aria-hidden="true">#</a></h3><p>概念：纯数据字段指的是那些不用于界面渲染的 <code>data</code> 字段。 应用场景：例如有些情况下，某些 <code>data</code> 中的字段既不会展示在界面上，也不会传递给其他组件，仅仅在当前 组件内部使用。带有这种特性的 <code>data</code> 字段适合被设置为纯数据字段。 好处：纯数据字段有助于提升页面更新的性能。</p><h3 id="使用规则" tabindex="-1">使用规则 <a class="header-anchor" href="#使用规则" aria-hidden="true">#</a></h3><p>在 <code>Component</code> 构造器的 <code>options</code> 节点中，指定 <code>pureDataPattern</code> 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段，示例代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708773978-6ef5fe4d-7c4a-423d-846b-65d71813c707.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=306&amp;id=ud4418095&amp;name=image.png&amp;originHeight=399&amp;originWidth=837&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=65574&amp;status=done&amp;style=none&amp;taskId=u9338bffe-20d1-4be4-9953-0622eda3754&amp;title=&amp;width=642.8159803828131" alt="image.png"></p><h3 id="使用纯数据字段改造数据监听器案例" tabindex="-1">使用纯数据字段改造数据监听器案例 <a class="header-anchor" href="#使用纯数据字段改造数据监听器案例" aria-hidden="true">#</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708801245-80851776-efc8-471e-8d34-b8a897168d19.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=421&amp;id=u01fab777&amp;name=image.png&amp;originHeight=548&amp;originWidth=834&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=80523&amp;status=done&amp;style=none&amp;taskId=uef3fade4-66b8-4c4a-95ae-e74bd85195b&amp;title=&amp;width=640.5119804531256" alt="image.png"></p><h2 id="组件的生命周期" tabindex="-1">组件的生命周期 <a class="header-anchor" href="#组件的生命周期" aria-hidden="true">#</a></h2><h3 id="组件全部的生命周期函数" tabindex="-1">组件全部的生命周期函数 <a class="header-anchor" href="#组件全部的生命周期函数" aria-hidden="true">#</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708827005-8a76e138-abb9-40fb-9aac-77c3ad0d898d.png#averageHue=%23c6d3e5&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=321&amp;id=udee8eb38&amp;name=image.png&amp;originHeight=418&amp;originWidth=1164&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=120612&amp;status=done&amp;style=none&amp;taskId=ua196d39d-6774-43e0-b80d-cb46da031d4&amp;title=&amp;width=893.9519727187509" alt="image.png"></p><h3 id="组件主要的生命周期函数" tabindex="-1">组件主要的生命周期函数 <a class="header-anchor" href="#组件主要的生命周期函数" aria-hidden="true">#</a></h3><p>在小程序组件中，最重要的生命周期函数有 3 个，分别是 <code>created</code>、<code>attached</code>、detached。它们各自的特点 如下：</p><ol><li>组件实例刚被创建好的时候，<code>created</code> 生命周期函数会被触发 <ol><li>此时还不能调用 <code>setData</code></li><li>通常在这个生命周期函数中，只应该用于给组件的 <code>this</code> 添加一些自定义的属性字段</li></ol></li><li>在组件完全初始化完毕、进入页面节点树后， <code>attached</code> 生命周期函数会被触发 <ol><li>此时， <code>this.data</code> 已被初始化完毕</li><li>这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据）</li></ol></li><li>在组件离开页面节点树后， <code>detached</code> 生命周期函数会被触发 <ol><li>退出一个页面时，会触发页面内每个自定义组件的 <code>detached</code> 生命周期函数</li><li>此时适合做一些清理性质的工作</li></ol></li></ol><h3 id="lifetimes-节点" tabindex="-1">lifetimes 节点 <a class="header-anchor" href="#lifetimes-节点" aria-hidden="true">#</a></h3><p>在小程序组件中，生命周期函数可以直接定义在 <code>Component</code> 构造器的第一级参数中，可以在 <code>lifetimes</code> 字段内进行声明（这是推荐的方式，其优先级最高）。示例代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708886568-00a6a537-60fb-48c5-80b1-d68fe63270f2.png#averageHue=%230d1223&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=300&amp;id=u303141c0&amp;name=image.png&amp;originHeight=390&amp;originWidth=837&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=89075&amp;status=done&amp;style=none&amp;taskId=ubb0cc24e-0e45-4d73-94d1-f9030badb13&amp;title=&amp;width=642.8159803828131" alt="image.png"></p><h2 id="组件所在页面的生命周期" tabindex="-1">组件所在页面的生命周期 <a class="header-anchor" href="#组件所在页面的生命周期" aria-hidden="true">#</a></h2><h3 id="什么是组件所在页面的生命周期" tabindex="-1">什么是组件所在页面的生命周期 <a class="header-anchor" href="#什么是组件所在页面的生命周期" aria-hidden="true">#</a></h3><p>有时，自定义组件的行为依赖于页面状态的变化，此时就需要用到组件所在页面的生命周期。 例如：每当触发页面的 <code>show</code> 生命周期函数的时候，我们希望能够重新生成一个随机的 RGB 颜色值。 在自定义组件中，组件所在页面的生命周期函数有如下 3 个，分别是： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708922037-1118039f-a8b7-4e90-b00f-fad09db33fe0.png#averageHue=%23b5c6de&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=207&amp;id=u3947dee1&amp;name=image.png&amp;originHeight=269&amp;originWidth=1143&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=66677&amp;status=done&amp;style=none&amp;taskId=u940b6445-feb0-446b-b658-6241f0e3ea5&amp;title=&amp;width=877.8239732109383" alt="image.png"></p><h3 id="pagelifetimes-节点" tabindex="-1">pageLifetimes 节点 <a class="header-anchor" href="#pagelifetimes-节点" aria-hidden="true">#</a></h3><p>组件所在页面的生命周期函数，需要定义在 <code>pageLifetimes</code> 节点中，示例代码如下 <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708940331-92d44242-93da-46a5-81f3-9f97e961c05b.png#averageHue=%230d1222&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=265&amp;id=ua49acc56&amp;name=image.png&amp;originHeight=345&amp;originWidth=884&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=66665&amp;status=done&amp;style=none&amp;taskId=u68448fd0-2f34-4998-a462-10588213956&amp;title=&amp;width=678.9119792812506" alt="image.png"></p><h3 id="生成随机的-rgb-颜色值" tabindex="-1">生成随机的 RGB 颜色值 <a class="header-anchor" href="#生成随机的-rgb-颜色值" aria-hidden="true">#</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708968966-0cdd97b0-3481-4561-bd1d-897ab778a7c4.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=439&amp;id=uc23a21f3&amp;name=image.png&amp;originHeight=572&amp;originWidth=887&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=100538&amp;status=done&amp;style=none&amp;taskId=ud528f540-d135-4ee3-800c-0529840fba2&amp;title=&amp;width=681.2159792109381" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678708978419-15777477-3cd5-4fbe-a0c0-8936fdfe41a3.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=287&amp;id=u3889c390&amp;name=image.png&amp;originHeight=374&amp;originWidth=874&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=66918&amp;status=done&amp;style=none&amp;taskId=uec28be56-ab69-43de-ade6-4c2392c89b8&amp;title=&amp;width=671.2319795156257" alt="image.png"></p><h2 id="插槽" tabindex="-1">插槽 <a class="header-anchor" href="#插槽" aria-hidden="true">#</a></h2><h3 id="什么是插槽" tabindex="-1">什么是插槽 <a class="header-anchor" href="#什么是插槽" aria-hidden="true">#</a></h3><p>在自定义组件的 <code>wxml</code> 结构中，可以提供一个<code>&lt;slot&gt;</code> 节点（插槽），用于承载组件使用者提供的 <code>wxml</code> 结构。 <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709008207-7143e2ba-8fb9-43ed-a14f-3f27a0bf859e.png#averageHue=%23e4e5e3&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=361&amp;id=ubc5318e1&amp;name=image.png&amp;originHeight=470&amp;originWidth=615&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=91601&amp;status=done&amp;style=none&amp;taskId=ucef1040b-9086-4c04-9a71-b070521bd66&amp;title=&amp;width=472.31998558593796" alt="image.png"></p><h3 id="单个插槽" tabindex="-1">单个插槽 <a class="header-anchor" href="#单个插槽" aria-hidden="true">#</a></h3><p>在小程序中，默认每个自定义组件中只允许使用一个 <code>&lt;slot&gt; </code>进行占位，这种个数上的限制叫做单个插槽。 <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709033445-8cb61fdb-ef53-4f44-9f9d-72f80c1a64db.png#averageHue=%230f1324&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=382&amp;id=u708426e9&amp;name=image.png&amp;originHeight=498&amp;originWidth=867&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=113593&amp;status=done&amp;style=none&amp;taskId=u10a2b25b-1af1-4d3a-bbd1-23f48fa5250&amp;title=&amp;width=665.8559796796882" alt="image.png"></p><h3 id="启用多个插槽" tabindex="-1">启用多个插槽 <a class="header-anchor" href="#启用多个插槽" aria-hidden="true">#</a></h3><p>在小程序的自定义组件中，需要使用多 <code>&lt;slot&gt;</code> 插槽时，可以在组件的 <code>.js</code> 文件中，通过如下方式进行启用。 示例代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709049421-a12f7d70-40bf-451d-98a2-c23b807544ff.png#averageHue=%230d1222&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=269&amp;id=uca473766&amp;name=image.png&amp;originHeight=350&amp;originWidth=885&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=58450&amp;status=done&amp;style=none&amp;taskId=uc41c9728-91da-4246-9e28-7bc35ecdeda&amp;title=&amp;width=679.6799792578131" alt="image.png"></p><h3 id="定义多个插槽" tabindex="-1">定义多个插槽 <a class="header-anchor" href="#定义多个插槽" aria-hidden="true">#</a></h3><p>可以在组件的 <code>.wxml</code> 中使用多个 <code>&lt;slot&gt;</code> 标签，以不同的 <code>name</code> 来区分不同的插槽。示例代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709085748-3dd7bbfb-097b-4cae-9385-1266cd8986f5.png#averageHue=%230e1324&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=281&amp;id=u0ac8cdd7&amp;name=image.png&amp;originHeight=366&amp;originWidth=868&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=82305&amp;status=done&amp;style=none&amp;taskId=u2939152f-7bac-4366-beaf-693a1a41f8b&amp;title=&amp;width=666.6239796562506" alt="image.png"></p><h3 id="使用多个插槽" tabindex="-1">使用多个插槽 <a class="header-anchor" href="#使用多个插槽" aria-hidden="true">#</a></h3><p>在使用带有多个插槽的自定义组件时，需要用 <code>slot</code> 属性来将节点插入到不同的 <code>&lt;slot&gt;</code> 中。示例代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709110129-47275d3a-b57c-4e39-8bd7-73d3c666b0ee.png#averageHue=%23101426&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=243&amp;id=u973b85ee&amp;name=image.png&amp;originHeight=316&amp;originWidth=853&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=104667&amp;status=done&amp;style=none&amp;taskId=u26806160-3e38-445f-9573-34eb6404da1&amp;title=&amp;width=655.1039800078131" alt="image.png"></p><h2 id="父子组件之间的通信" tabindex="-1">父子组件之间的通信 <a class="header-anchor" href="#父子组件之间的通信" aria-hidden="true">#</a></h2><h3 id="父子组件之间通信的-3-种方式" tabindex="-1">父子组件之间通信的 3 种方式 <a class="header-anchor" href="#父子组件之间通信的-3-种方式" aria-hidden="true">#</a></h3><ol><li>属性绑定 <ol><li>用于父组件向子组件的指定属性设置数据，仅能设置 <code>JSON</code> 兼容的数据</li></ol></li><li>事件绑定 <ol><li>用于子组件向父组件传递数据，可以传递任意数据</li></ol></li><li>获取组件实例 <ol><li>父组件还可以通过 <code>this.selectComponent() </code>获取子组件实例对象</li><li>这样就可以直接访问子组件的任意数据和方法</li></ol></li></ol><h3 id="属性绑定" tabindex="-1">属性绑定 <a class="header-anchor" href="#属性绑定" aria-hidden="true">#</a></h3><p>属性绑定用于实现父向子传值，而且只能传递普通类型的数据，无法将方法传递给子组件。父组件的示例代码 如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709160140-ec1a8098-45ba-40ed-9773-b596cd7b20aa.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=284&amp;id=u2fa5e962&amp;name=image.png&amp;originHeight=370&amp;originWidth=723&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=64568&amp;status=done&amp;style=none&amp;taskId=u2582cf62-e557-4ee7-bf3a-cca96d10dc9&amp;title=&amp;width=555.263983054688" alt="image.png"> 子组件在 <code>properties</code> 节点中声明对应的属性并使用。示例代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709179784-d10f0e19-b1cc-49e5-ade1-e3f537b9b87f.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=250&amp;id=u550d1394&amp;name=image.png&amp;originHeight=325&amp;originWidth=857&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=62517&amp;status=done&amp;style=none&amp;taskId=u2bd0c88f-29ea-47be-9bb5-e3887886833&amp;title=&amp;width=658.1759799140631" alt="image.png"></p><h3 id="事件绑定" tabindex="-1">事件绑定 <a class="header-anchor" href="#事件绑定" aria-hidden="true">#</a></h3><p>事件绑定用于实现子向父传值，可以传递任何类型的数据。使用步骤如下：</p><ol><li>在父组件的 <code>js</code> 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件</li><li>在父组件的 <code>wxml</code> 中，通过自定义事件的形式，将步骤 1 中定义的函数引用，传递给子组件</li><li>在子组件的 <code>js</code> 中，通过调用 <code>this.triggerEvent(&#39;自定义事件名称&#39;, { /* 参数对象 */ })</code> ，将数据发送到父组件</li><li>在父组件的 <code>js</code> 中，通过 <code>e.detail</code> 获取到子组件传递过来的数据</li></ol><p>步骤1：在父组件的 js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件。 <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709216845-609b61de-49bb-477e-aa21-a69f20dcc5ff.png#averageHue=%230e1223&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=198&amp;id=u26254466&amp;name=image.png&amp;originHeight=258&amp;originWidth=857&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=61735&amp;status=done&amp;style=none&amp;taskId=u494b7600-7a7a-4586-af04-ce05536ac47&amp;title=&amp;width=658.1759799140631" alt="image.png"> 步骤2：在父组件的 <code>wxml</code> 中，通过自定义事件的形式，将步骤 1 中定义的函数引用，传递给子组件。 <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709230456-961ef3cf-0996-4380-8783-21213da2eeb3.png#averageHue=%23101425&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=182&amp;id=u67bad8f2&amp;name=image.png&amp;originHeight=237&amp;originWidth=881&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=74146&amp;status=done&amp;style=none&amp;taskId=ufbb9c26c-3b26-44ce-9f18-8398a580e31&amp;title=&amp;width=676.6079793515631" alt="image.png"> 步骤3：在子组件的 <code>js </code>中，通过调用<code>this.triggerEvent(‘自定义事件名称’, { /* 参数对象 */ })</code>，将数据发送到父组件。 <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709246087-ab164a0a-2915-4933-9ec8-ef9c8817deaf.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=385&amp;id=u82097783&amp;name=image.png&amp;originHeight=501&amp;originWidth=835&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=89736&amp;status=done&amp;style=none&amp;taskId=u3959f27e-2223-47b7-a2e2-0b8a5d04b9e&amp;title=&amp;width=641.2799804296881" alt="image.png"> 步骤4：在父组件的 <code>js</code> 中，通过 <code>e.detail</code> 获取到子组件传递过来的数据。 <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709261048-a23954ae-5895-4253-8447-022f05b004d4.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=221&amp;id=ue96c104d&amp;name=image.png&amp;originHeight=288&amp;originWidth=854&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=52423&amp;status=done&amp;style=none&amp;taskId=u7638bcac-5027-4849-ab6b-6e53ce0beac&amp;title=&amp;width=655.8719799843756" alt="image.png"></p><h3 id="获取组件实例" tabindex="-1">获取组件实例 <a class="header-anchor" href="#获取组件实例" aria-hidden="true">#</a></h3><p>可在父组件里调用 <code>this.selectComponent(&quot;id或class选择器&quot;)</code> ，获取子组件的实例对象，从而直接访问子组件的任意数据和方法。调用时需要传入一个选择器，例如 <code>this.selectComponent(&quot;.my-component&quot;)</code>。 <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709299327-7c50b0fa-a0a5-45c4-bf68-1f07001d2fbd.png#averageHue=%230e1223&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=344&amp;id=uffdfb303&amp;name=image.png&amp;originHeight=448&amp;originWidth=866&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=125786&amp;status=done&amp;style=none&amp;taskId=u98a492ad-04ed-482a-a919-87be47516b7&amp;title=&amp;width=665.0879797031256" alt="image.png"></p><h2 id="behaviors" tabindex="-1">behaviors <a class="header-anchor" href="#behaviors" aria-hidden="true">#</a></h2><h3 id="什么是-behaviors" tabindex="-1">什么是 behaviors <a class="header-anchor" href="#什么是-behaviors" aria-hidden="true">#</a></h3><p><code>behaviors</code> 是小程序中，用于实现组件间代码共享的特性，类似于 <code>Vue.js</code> 中的 “<code>mixins</code>”。 <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709335189-0dac297e-1e6d-4105-9416-453c709cad07.png#averageHue=%23fcfcfc&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=213&amp;id=ue0042930&amp;name=image.png&amp;originHeight=277&amp;originWidth=423&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=47552&amp;status=done&amp;style=none&amp;taskId=u6eea064d-4151-4361-a401-6df191a812a&amp;title=&amp;width=324.8639900859378" alt="image.png"></p><h3 id="behaviors-的工作方式" tabindex="-1">behaviors 的工作方式 <a class="header-anchor" href="#behaviors-的工作方式" aria-hidden="true">#</a></h3><p>每个 <code>behavior</code> 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和方法会被 合并到组件中。 每个组件可以引用多个 <code>behavior</code>，<code>behavior</code> 也可以引用其它 <code>behavior</code>。</p><h3 id="创建-behavior" tabindex="-1">创建 behavior <a class="header-anchor" href="#创建-behavior" aria-hidden="true">#</a></h3><p>调用 <code>Behavior(Object object)</code> 方法即可创建一个共享的 <code>behavior</code> 实例对象，供所有的组件使用： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709375054-6121ef28-6421-4112-8ffc-6aa16e071994.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=330&amp;id=ubf7cbe14&amp;name=image.png&amp;originHeight=430&amp;originWidth=826&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=91035&amp;status=done&amp;style=none&amp;taskId=ua45f1a26-60b9-4800-a1e1-35c8e86a98c&amp;title=&amp;width=634.3679806406255" alt="image.png"></p><h3 id="导入并使用-behavior" tabindex="-1">导入并使用 behavior <a class="header-anchor" href="#导入并使用-behavior" aria-hidden="true">#</a></h3><p>在组件中，使用 <code>require() </code>方法导入需要的 <code>behavior</code>，挂载后即可访问 <code>behavior</code> 中的数据或方法，示例代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709409772-c9468c37-1c80-4b16-8a5f-bc9ff52bd24e.png#averageHue=%230d1223&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=276&amp;id=u3d7edfbf&amp;name=image.png&amp;originHeight=360&amp;originWidth=864&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=77613&amp;status=done&amp;style=none&amp;taskId=u99ed9a4b-b689-4110-9deb-38d83ad7689&amp;title=&amp;width=663.5519797500007" alt="image.png"></p><h3 id="behavior-中所有可用的节点" tabindex="-1">behavior 中所有可用的节点 <a class="header-anchor" href="#behavior-中所有可用的节点" aria-hidden="true">#</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709425532-9ee03e1b-2c38-49ed-82c0-4fa2a715c31a.png#averageHue=%23c9d4e5&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=419&amp;id=uaea30523&amp;name=image.png&amp;originHeight=546&amp;originWidth=1163&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=134257&amp;status=done&amp;style=none&amp;taskId=uea87641e-de86-4a41-a24a-061c8ccf544&amp;title=&amp;width=893.1839727421883" alt="image.png"></p><h3 id="同名字段的覆盖和组合规则" tabindex="-1">同名字段的覆盖和组合规则* <a class="header-anchor" href="#同名字段的覆盖和组合规则" aria-hidden="true">#</a></h3><ol><li>组件和它引用的 <code>behavior</code> 中可以包含同名的字段，此时可以参考如下 3 种同名时的处理规则：</li><li>同名的数据字段 (<code>data</code>)</li><li>同名的属性 (<code>properties</code>) 或方法 (<code>methods</code>)</li><li>同名的生命周期函数</li></ol><p>关于详细的覆盖和组合规则，大家可以参考微信小程序官方文档给出的说明： <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html" target="_blank" rel="noreferrer">https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html</a></p><h1 id="使用npm包" tabindex="-1">使用npm包 <a class="header-anchor" href="#使用npm包" aria-hidden="true">#</a></h1><h2 id="小程序对-npm-的支持与限制" tabindex="-1">小程序对 npm 的支持与限制 <a class="header-anchor" href="#小程序对-npm-的支持与限制" aria-hidden="true">#</a></h2><p>目前，小程序中已经支持使用 <code>npm</code> 安装第三方包，从而来提高小程序的开发效率。但是，在小程序中使用 <code>npm</code> 包有如下 3 个限制：</p><ol><li>不支持依赖于 Node.js 内置库的包</li><li>不支持依赖于浏览器内置对象的包</li><li>不支持依赖于 C++ 插件的包</li></ol><p>总结：虽然 npm 上的包有千千万，但是能供小程序使用的包却“为数不多”。</p><h2 id="vant-weapp" tabindex="-1">Vant Weapp <a class="header-anchor" href="#vant-weapp" aria-hidden="true">#</a></h2><h3 id="什么是-vant-weapp" tabindex="-1">什么是 Vant Weapp <a class="header-anchor" href="#什么是-vant-weapp" aria-hidden="true">#</a></h3><p>Vant Weapp 是有赞前端团队开源的一套小程序 UI 组件库，助力开发者快速搭建小程序应用。它所使用的是 MIT 开源许可协议，对商业使用比较友好。 官方文档地址 <a href="https://youzan.github.io/vant-weapp" target="_blank" rel="noreferrer">https://youzan.github.io/vant-weapp</a> 扫描下方的小程序二维码，体验组件库示例： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709566516-2d06b35a-9f0a-4f8d-9648-0f2b7242f04d.png#averageHue=%23e7e7e7&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=217&amp;id=u59dcd5aa&amp;name=image.png&amp;originHeight=282&amp;originWidth=297&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=67999&amp;status=done&amp;style=none&amp;taskId=u865d73a1-2104-4602-9f17-cd22bef7727&amp;title=&amp;width=228.0959930390627" alt="image.png"></p><h3 id="安装-vant-组件库" tabindex="-1">安装 Vant 组件库 <a class="header-anchor" href="#安装-vant-组件库" aria-hidden="true">#</a></h3><p>在小程序项目中，安装 Vant 组件库主要分为如下 3 步：</p><ol><li>通过 npm 安装（建议指定版本为@1.3.3）</li><li>构建 npm 包</li><li>修改 app.json</li></ol><p>详细的操作步骤，大家可以参考 Vant 官方提供的快速上手教程： <a href="https://youzan.github.io/vant-weapp/#/quickstart#an-zhuang" target="_blank" rel="noreferrer">https://youzan.github.io/vant-weapp/#/quickstart#an-zhuang</a></p><h3 id="使用-vant-组件" tabindex="-1">使用 Vant 组件 <a class="header-anchor" href="#使用-vant-组件" aria-hidden="true">#</a></h3><p>安装完 Vant 组件库之后，可以在 app.json 的 usingComponents 节点中引入需要的组件，即可在 wxml 中 直接使用组件。示例代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709606216-0f009529-7a94-4512-960d-949c7df7bf23.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=260&amp;id=u08f06aa9&amp;name=image.png&amp;originHeight=339&amp;originWidth=863&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=59139&amp;status=done&amp;style=none&amp;taskId=u297fb3c2-09c1-4b82-a4e1-ec5b4590467&amp;title=&amp;width=662.7839797734381" alt="image.png"></p><h3 id="定制全局主题样式" tabindex="-1">定制全局主题样式 <a class="header-anchor" href="#定制全局主题样式" aria-hidden="true">#</a></h3><p>Vant Weapp 使用 CSS 变量来实现定制主题。 关于 CSS 变量的基本用法，请参考 MDN 文档： <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties</a></p><p>在 app.wxss 中，写入 CSS 变量，即可对全局生效： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709646268-0093023d-ecd8-4e05-85fc-d49de9775773.png#averageHue=%230d1222&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=220&amp;id=u682774dc&amp;name=image.png&amp;originHeight=287&amp;originWidth=859&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=65832&amp;status=done&amp;style=none&amp;taskId=u85a00d37-1fef-4273-a138-d482f0a5544&amp;title=&amp;width=659.7119798671881" alt="image.png"> 所有可用的颜色变量，请参考 Vant 官方提供的配置文件： <a href="https://github.com/youzan/vant-weapp/blob/dev/packages/common/style/var.less" target="_blank" rel="noreferrer">https://github.com/youzan/vant-weapp/blob/dev/packages/common/style/var.less</a></p><h2 id="api-promise化" tabindex="-1">API Promise化 <a class="header-anchor" href="#api-promise化" aria-hidden="true">#</a></h2><h3 id="基于回调函数的异步-api-的缺点" tabindex="-1">基于回调函数的异步 API 的缺点 <a class="header-anchor" href="#基于回调函数的异步-api-的缺点" aria-hidden="true">#</a></h3><p>默认情况下，小程序官方提供的异步 API 都是基于回调函数实现的，例如，网络请求的 API 需要按照如下的方 式调用： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709788416-e1a22895-01c0-45cb-8f29-9bdf03062b69.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=272&amp;id=ub1f2a83a&amp;name=image.png&amp;originHeight=354&amp;originWidth=856&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=63629&amp;status=done&amp;style=none&amp;taskId=u614176dd-be87-49ea-9a55-279c5b7ac14&amp;title=&amp;width=657.4079799375006" alt="image.png"> 缺点：容易造成回调地狱的问题，代码的可读性、维护性差！</p><h3 id="什么是-api-promise-化" tabindex="-1">什么是 API Promise 化 <a class="header-anchor" href="#什么是-api-promise-化" aria-hidden="true">#</a></h3><p>API Promise化，指的是通过额外的配置，将官方提供的、基于回调函数的异步 API，升级改造为基于 Promise 的异步 API，从而提高代码的可读性、维护性，避免回调地狱的问题。</p><h3 id="实现-api-promise-化" tabindex="-1">实现 API Promise 化 <a class="header-anchor" href="#实现-api-promise-化" aria-hidden="true">#</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709843504-e4b79cca-1a8a-4d9b-a7b8-539356e05bf2.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=347&amp;id=u29ebd335&amp;name=image.png&amp;originHeight=452&amp;originWidth=860&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=87979&amp;status=done&amp;style=none&amp;taskId=u22243947-2e9a-49e6-a4ce-241fee1b02c&amp;title=&amp;width=660.4799798437506" alt="image.png"></p><h3 id="调用-promise-化之后的异步-api" tabindex="-1">调用 Promise 化之后的异步 API <a class="header-anchor" href="#调用-promise-化之后的异步-api" aria-hidden="true">#</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709860219-6e41e591-10d0-46e5-b19f-5ee96bb39788.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=424&amp;id=u8c07490a&amp;name=image.png&amp;originHeight=552&amp;originWidth=874&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=98366&amp;status=done&amp;style=none&amp;taskId=uf16c94bc-3898-42ef-b643-be4220c936c&amp;title=&amp;width=671.2319795156257" alt="image.png"></p><h1 id="全局数据共享" tabindex="-1">全局数据共享 <a class="header-anchor" href="#全局数据共享" aria-hidden="true">#</a></h1><h2 id="什么是全局数据共享" tabindex="-1">什么是全局数据共享 <a class="header-anchor" href="#什么是全局数据共享" aria-hidden="true">#</a></h2><p>全局数据共享（又叫做：状态管理）是为了解决组件之间数据共享的问题。 开发中常用的全局数据共享方案有：Vuex、Redux、MobX 等。 <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709909395-c778d864-8359-4f9c-b069-4a8434946708.png#averageHue=%23f1f0ef&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=282&amp;id=ud23ddd19&amp;name=image.png&amp;originHeight=367&amp;originWidth=701&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=172015&amp;status=done&amp;style=none&amp;taskId=u250f4048-8301-43f2-94f5-359041982e1&amp;title=&amp;width=538.367983570313" alt="image.png"></p><h2 id="小程序中的全局数据共享方案" tabindex="-1">小程序中的全局数据共享方案 <a class="header-anchor" href="#小程序中的全局数据共享方案" aria-hidden="true">#</a></h2><p>在小程序中，可使用 mobx-miniprogram 配合 mobx-miniprogram-bindings 实现全局数据共享。其中：</p><ol><li>mobx-miniprogram 用来创建 Store 实例对象</li><li>mobx-miniprogram-bindings 用来把 Store 中的共享数据或方法，绑定到组件或页面中使用</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709939062-05232dfa-a8fe-4749-8a32-04bc34f726eb.png#averageHue=%23f1f0ee&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=266&amp;id=u8decc612&amp;name=image.png&amp;originHeight=347&amp;originWidth=460&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=107348&amp;status=done&amp;style=none&amp;taskId=u09549db6-49c6-430f-9cf0-5677f495dac&amp;title=&amp;width=353.2799892187503" alt="image.png"></p><h3 id="mobx" tabindex="-1">MobX <a class="header-anchor" href="#mobx" aria-hidden="true">#</a></h3><h4 id="安装-mobx-相关的包" tabindex="-1">安装 MobX 相关的包 <a class="header-anchor" href="#安装-mobx-相关的包" aria-hidden="true">#</a></h4><p>在项目中运行如下的命令，安装 MobX 相关的包： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709960543-744a9323-1e07-40ae-88ee-690e1416effd.png#averageHue=%230e1222&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=101&amp;id=u28eb5e12&amp;name=image.png&amp;originHeight=131&amp;originWidth=865&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=32529&amp;status=done&amp;style=none&amp;taskId=u7b3d9248-4b03-41e4-b51f-c48786d7729&amp;title=&amp;width=664.3199797265631" alt="image.png"> 注意：MobX 相关的包安装完毕之后，记得删除 miniprogram_npm 目录后，重新构建 npm。</p><h4 id="创建-mobx-的-store-实例" tabindex="-1">创建 MobX 的 Store 实例 <a class="header-anchor" href="#创建-mobx-的-store-实例" aria-hidden="true">#</a></h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678709985522-cae784ec-091f-47a6-94e0-10f477979730.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=448&amp;id=ue7664517&amp;name=image.png&amp;originHeight=583&amp;originWidth=733&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=87245&amp;status=done&amp;style=none&amp;taskId=u201b3f3a-3244-4f4f-8b61-2afb73a4f5f&amp;title=&amp;width=562.9439828203131" alt="image.png"></p><h4 id="将-store-中的成员绑定到页面中" tabindex="-1">将 Store 中的成员绑定到页面中 <a class="header-anchor" href="#将-store-中的成员绑定到页面中" aria-hidden="true">#</a></h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678710015390-9870d975-58ae-47ce-84f1-88db4cc09c20.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=449&amp;id=ud9c5574d&amp;name=image.png&amp;originHeight=585&amp;originWidth=819&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=109946&amp;status=done&amp;style=none&amp;taskId=u6c3b8a3a-c42d-4fa8-9fee-4208324fec8&amp;title=&amp;width=628.9919808046881" alt="image.png"></p><h4 id="在页面上使用-store-中的成员" tabindex="-1">在页面上使用 Store 中的成员 <a class="header-anchor" href="#在页面上使用-store-中的成员" aria-hidden="true">#</a></h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678710030699-99e85dc8-012f-41f2-b6dc-fd2238077332.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=411&amp;id=uf4371de7&amp;name=image.png&amp;originHeight=535&amp;originWidth=870&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=101103&amp;status=done&amp;style=none&amp;taskId=u1bfe9150-7e75-4c9e-88d8-e28ef2f10ac&amp;title=&amp;width=668.1599796093756" alt="image.png"></p><h4 id="将-store-中的成员绑定到组件中" tabindex="-1">将 Store 中的成员绑定到组件中 <a class="header-anchor" href="#将-store-中的成员绑定到组件中" aria-hidden="true">#</a></h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678710044907-a7c6f66e-75c8-4474-971e-91c5cd976beb.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=463&amp;id=u932c8e4f&amp;name=image.png&amp;originHeight=603&amp;originWidth=732&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=113123&amp;status=done&amp;style=none&amp;taskId=u6fe088b9-3eee-443a-890c-cdd525db342&amp;title=&amp;width=562.1759828437505" alt="image.png"></p><h4 id="在组件中使用-store-中的成员" tabindex="-1">在组件中使用 Store 中的成员 <a class="header-anchor" href="#在组件中使用-store-中的成员" aria-hidden="true">#</a></h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678710061691-2636cf40-3bbb-4402-bf39-67180d08874b.png#averageHue=%230d1122&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=446&amp;id=ua7601af6&amp;name=image.png&amp;originHeight=581&amp;originWidth=852&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=104464&amp;status=done&amp;style=none&amp;taskId=u5e5d5dfe-1120-48e5-b11f-880cd34f33f&amp;title=&amp;width=654.3359800312506" alt="image.png"></p><h1 id="分包" tabindex="-1">分包 <a class="header-anchor" href="#分包" aria-hidden="true">#</a></h1><h2 id="什么是分包" tabindex="-1">什么是分包 <a class="header-anchor" href="#什么是分包" aria-hidden="true">#</a></h2><p>分包指的是把一个完整的小程序项目，按照需求划分为不同的子包，在构建时打包成不同的分包，用户在使用 时按需进行加载。</p><h2 id="分包的好处" tabindex="-1">分包的好处 <a class="header-anchor" href="#分包的好处" aria-hidden="true">#</a></h2><p>对小程序进行分包的好处主要有以下两点：</p><ol><li>可以优化小程序首次启动的下载时间</li><li>在多团队共同开发时可以更好的解耦协作</li></ol><h2 id="分包前项目的构成" tabindex="-1">分包前项目的构成 <a class="header-anchor" href="#分包前项目的构成" aria-hidden="true">#</a></h2><p>分包前，小程序项目中所有的页面和资源都被打包到了一起，导致整个项目体积过大，影响小程序首次启动的 下载时间。 <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678710120541-5ae8f175-904c-44a5-a35e-eb420d50804f.png#averageHue=%23fcf2eb&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=259&amp;id=u440eef57&amp;name=image.png&amp;originHeight=337&amp;originWidth=638&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=59802&amp;status=done&amp;style=none&amp;taskId=u1244114c-c048-41c7-9c8d-9aee4436801&amp;title=&amp;width=489.98398504687543" alt="image.png"></p><h2 id="分包后项目的构成" tabindex="-1">分包后项目的构成 <a class="header-anchor" href="#分包后项目的构成" aria-hidden="true">#</a></h2><p>分包后，小程序项目由 1 个主包 + 多个分包组成：</p><ol><li>主包：一般只包含项目的启动页面或 TabBar 页面、以及所有分包都需要用到的一些公共资源</li><li>分包：只包含和当前分包有关的页面和私有资源</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678710136885-ece81608-a1b0-4aae-b67a-82955fef16cf.png#averageHue=%23fcf8f5&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=284&amp;id=u0f224b2a&amp;name=image.png&amp;originHeight=370&amp;originWidth=1256&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=85698&amp;status=done&amp;style=none&amp;taskId=u8f5098c9-8ca3-4364-b58a-f7a9bf63550&amp;title=&amp;width=964.6079705625009" alt="image.png"></p><h2 id="分包的加载规则" tabindex="-1">分包的加载规则 <a class="header-anchor" href="#分包的加载规则" aria-hidden="true">#</a></h2><ol><li>在小程序启动时，默认会下载主包并启动主包内页面 <ol><li>tabBar 页面需要放到主包中</li></ol></li><li>当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示 <ol><li>非 tabBar 页面可以按照功能的不同，划分为不同的分包之后，进行按需下载</li></ol></li></ol><h2 id="分包的体积限制" tabindex="-1">分包的体积限制 <a class="header-anchor" href="#分包的体积限制" aria-hidden="true">#</a></h2><p>目前，小程序分包的大小有以下两个限制：</p><ol><li>整个小程序所有分包大小不超过 16M（主包 + 所有分包）</li><li>单个分包/主包大小不能超过 2M</li></ol><h2 id="使用分包" tabindex="-1">使用分包 <a class="header-anchor" href="#使用分包" aria-hidden="true">#</a></h2><h3 id="配置方法" tabindex="-1">配置方法 <a class="header-anchor" href="#配置方法" aria-hidden="true">#</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678710213373-cd1e8521-2b52-4e93-b4e0-369f5d6cd0d3.png#averageHue=%236b777e&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=451&amp;id=ud746688b&amp;name=image.png&amp;originHeight=587&amp;originWidth=1060&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=172974&amp;status=done&amp;style=none&amp;taskId=ub18c8732-4c45-49ce-81c0-2164bb7a36f&amp;title=&amp;width=814.0799751562507" alt="image.png"></p><h3 id="打包原则" tabindex="-1">打包原则 <a class="header-anchor" href="#打包原则" aria-hidden="true">#</a></h3><ol><li>小程序会按 subpackages 的配置进行分包，subpackages 之外的目录将被打包到主包中</li><li>主包也可以有自己的 pages（即最外层的 pages 字段）</li><li>tabBar 页面必须在主包内</li><li>分包之间不能互相嵌套</li></ol><h3 id="引用原则" tabindex="-1">引用原则 <a class="header-anchor" href="#引用原则" aria-hidden="true">#</a></h3><ol><li>主包无法引用分包内的私有资源</li><li>分包之间不能相互引用私有资源</li><li>分包可以引用主包内的公共资源</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678710257762-9d26b2ad-df74-4e2d-93e2-eb17008674d2.png#averageHue=%23fcf7f5&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=290&amp;id=u661b3107&amp;name=image.png&amp;originHeight=377&amp;originWidth=1165&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=85457&amp;status=done&amp;style=none&amp;taskId=u14a8c718-a0cb-4ecb-ad5e-524af63ca9b&amp;title=&amp;width=894.7199726953133" alt="image.png"></p><h2 id="独立分包" tabindex="-1">独立分包 <a class="header-anchor" href="#独立分包" aria-hidden="true">#</a></h2><h3 id="什么是独立分包" tabindex="-1">什么是独立分包 <a class="header-anchor" href="#什么是独立分包" aria-hidden="true">#</a></h3><p>独立分包本质上也是分包，只不过它比较特殊，可以独立于主包和其他分包而单独运行。 <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678710289957-1ecbf914-a5d1-4498-b916-003c2f94ff83.png#averageHue=%23d5d5d2&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=257&amp;id=u7e15d704&amp;name=image.png&amp;originHeight=335&amp;originWidth=756&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=75559&amp;status=done&amp;style=none&amp;taskId=u725bf246-119e-4741-aae7-55d53217a79&amp;title=&amp;width=580.6079822812505" alt="image.png"></p><h3 id="独立分包和普通分包的区别" tabindex="-1">独立分包和普通分包的区别 <a class="header-anchor" href="#独立分包和普通分包的区别" aria-hidden="true">#</a></h3><p>最主要的区别：是否依赖于主包才能运行</p><ol><li>普通分包必须依赖于主包才能运行</li><li>独立分包可以在不下载主包的情况下，独立运行</li></ol><h3 id="独立分包的应用场景" tabindex="-1">独立分包的应用场景 <a class="header-anchor" href="#独立分包的应用场景" aria-hidden="true">#</a></h3><p>开发者可以按需，将某些具有一定功能独立性的页面配置到独立分包中。原因如下：</p><ol><li>当小程序从普通的分包页面启动时，需要首先下载主包</li><li>而独立分包不依赖主包即可运行，可以很大程度上提升分包页面的启动速度</li></ol><p>注意：一个小程序中可以有多个独立分包。</p><h3 id="独立分包的配置方法" tabindex="-1">独立分包的配置方法<img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678710384280-327e6f07-a25e-4181-9f7f-292d246e5f3a.png#averageHue=%23424c55&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=433&amp;id=u93e268a9&amp;name=image.png&amp;originHeight=564&amp;originWidth=1103&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=134625&amp;status=done&amp;style=none&amp;taskId=u746ca5ce-484b-477c-a1b5-d2b9b5a0ebc&amp;title=&amp;width=847.1039741484383" alt="image.png"> <a class="header-anchor" href="#独立分包的配置方法" aria-hidden="true">#</a></h3><h3 id="引用原则-1" tabindex="-1">引用原则 <a class="header-anchor" href="#引用原则-1" aria-hidden="true">#</a></h3><p>独立分包和普通分包以及主包之间，是相互隔绝的，不能相互引用彼此的资源！例如：</p><ol><li>主包无法引用独立分包内的私有资源</li><li>独立分包之间，不能相互引用私有资源</li><li>独立分包和普通分包之间，不能相互引用私有资源</li><li>特别注意：独立分包中不能引用主包内的公共资源</li></ol><h2 id="分包预下载" tabindex="-1">分包预下载 <a class="header-anchor" href="#分包预下载" aria-hidden="true">#</a></h2><h3 id="什么是分包预下载" tabindex="-1">什么是分包预下载 <a class="header-anchor" href="#什么是分包预下载" aria-hidden="true">#</a></h3><p>分包预下载指的是：在进入小程序的某个页面时，由框架自动预下载可能需要的分包，从而提升进入后续分包页面时的启动速度。</p><h3 id="配置分包的预下载" tabindex="-1">配置分包的预下载 <a class="header-anchor" href="#配置分包的预下载" aria-hidden="true">#</a></h3><p>预下载分包的行为，会在进入指定的页面时触发。在 app.json 中，使用 preloadRule 节点定义分包的预下载 规则，示例代码如下： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678710495285-6260d6ee-e1bb-4891-b56c-98563bef361b.png#averageHue=%230e1223&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=356&amp;id=uf7502e32&amp;name=image.png&amp;originHeight=464&amp;originWidth=878&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=98684&amp;status=done&amp;style=none&amp;taskId=ud5b3ff04-5eaa-4e2f-a9ca-80cacc90600&amp;title=&amp;width=674.3039794218756" alt="image.png"></p><h3 id="分包预下载的限制" tabindex="-1">分包预下载的限制 <a class="header-anchor" href="#分包预下载的限制" aria-hidden="true">#</a></h3><p>同一个分包中的页面享有共同的预下载大小限额 2M，例如： <img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678710522419-bae31ae1-12cb-4538-b944-bb3847d65d2b.png#averageHue=%23efe8d2&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=290&amp;id=u9ce46bc0&amp;name=image.png&amp;originHeight=378&amp;originWidth=986&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=92302&amp;status=done&amp;style=none&amp;taskId=u153cfc54-8207-40a7-b6a3-b060bac816e&amp;title=&amp;width=757.2479768906258" alt="image.png"></p><h1 id="自定义tabbar" tabindex="-1">自定义tabbar <a class="header-anchor" href="#自定义tabbar" aria-hidden="true">#</a></h1><h2 id="案例效果" tabindex="-1">案例效果 <a class="header-anchor" href="#案例效果" aria-hidden="true">#</a></h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/32665636/1678710592439-6aaa9248-11af-4de4-a718-8bc9c5022611.png#averageHue=%23fcf6f6&amp;clientId=ud3c121ea-017f-4&amp;from=paste&amp;height=441&amp;id=ub0aba5f8&amp;name=image.png&amp;originHeight=574&amp;originWidth=338&amp;originalType=binary&amp;ratio=1.3020833730697632&amp;rotation=0&amp;showTitle=false&amp;size=24607&amp;status=done&amp;style=none&amp;taskId=u6cce7562-4928-4fe1-be6c-ae09737db22&amp;title=&amp;width=259.5839920781252" alt="image.png"> 在此案例中，用到的主要知识点如下：</p><ol><li>自定义组件</li><li>Vant 组件库</li><li>MobX 数据共享</li><li>组件样式隔离</li><li>组件数据监听器</li><li>组件的 behaviors</li><li>Vant 样式覆盖</li></ol><h2 id="实现步骤" tabindex="-1">实现步骤 <a class="header-anchor" href="#实现步骤" aria-hidden="true">#</a></h2><p>自定义 tabBar 分为 3 大步骤，分别是：</p><ol><li>配置信息</li><li>添加 tabBar 代码文件</li><li>编写 tabBar 代码</li></ol><p>详细步骤，可以参考小程序官方给出的文档： <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html" target="_blank" rel="noreferrer">https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html</a></p>',206),n=[d];function m(r,l,o,h,s,c){return i(),e("div",null,n)}const f=a(t,[["render",m]]);export{u as __pageData,f as default};
